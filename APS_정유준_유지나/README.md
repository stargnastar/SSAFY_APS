# APS_ 정유준 유지나
**Git Repo** : https://lab.ssafy.com/s09/a07/ssafy9_test/-/tree/main/APS_%EC%A0%95%EC%9C%A0%EC%A4%80_%EC%9C%A0%EC%A7%80%EB%82%98

## ⭐ 프로젝트 목표
1. 실무에 적용할 수 있는 알고리즘 아이디어 도출
2. 도출된 아이디어를 실제로 적용할 수 있는 방법 탐색
3. 탐색된 아이디어와 연관된 알고리즘 학습 및 API추가 학습

## ⭐ 기능 
### Algo-01. 내 주변 헬스장 검색
- 요약
KAKAO지도에서 제공하는 **MapsAPI**를 활용하여 **키워드로 장소를 검색**하고, **지도에 마커**를 나타낸다.
  
- 상세
API에서 제공하는 검색된 장소 위치 기준 지**도 범위 안에 속하는 객체를 탐색**하고 **지도 해당 좌표에 마커를 생성**하여, 내 주변에서 가까운 키워드에 해당하는 헬스장들을 지도에 표현한다.

- 적용 알고리즘
**Pythagorean theorem** : 반경 1KM이내의 헬스장 목록을 검색.
```java
Pythagorean_Theorem(a, b, c):
    # a, b, c는 세 변의 길이를 나타내는 변수
    # a^2 + b^2 = c^2이 성립하는지 확인
    
    # 빗변(c)의 제곱이 나머지 두 변(a, b)의 제곱의 합과 같은지 확인
    if c * c == a * a + b * b:
        return True  # 피타고라스의 정리가 성립함
    else:
        return False  # 피타고라스의 정리가 성립하지 않음
```
**Boyer Moore** : 키워드에 해당하는 헬스장 목록을 검색.
```java
Boyer_Moore(text, pattern):
    # text: 전체 텍스트 문자열
    # pattern: 찾고자 하는 패턴 문자열

    n = len(text)  # 전체 텍스트의 길이
    m = len(pattern)  # 찾고자 하는 패턴의 길이
    skip = {}  # 미리 계산한 스킵 테이블

    # 스킵 테이블 초기화
    for i in range(n-1):
        skip[text[i]] = m

    for i in range(m):
        skip[pattern[i]] = m - 1 - i

    i = 0  # 텍스트의 인덱스
    while i <= n - m:
        j = m - 1  # 패턴의 인덱스

        # 패턴의 끝에서부터 비교하면서 일치하는지 확인
        while j >= 0 and text[i + j] == pattern[j]:
            j -= 1

        # 패턴이 일치하면 결과 반환
        if j == -1:
            return i

        # 일치하지 않는 경우 스킵 테이블을 참고하여 다음 인덱스로 이동
        if text[i + j] in skip:
            i += skip[text[i + j]]
        else:
            i += m

    return -1  # 패턴이 없는 경우 -1 반환


```

  
- 이점<br>
 ```1. 편의성 : 지도 API를 사용하여 사용자는 자신의 위치를 수동으로 입력하거나 찾아야 할 필요 없이, 위치 정보를 자동으로 가져오기 때문에 편리하게 사용할 수 있다.``` <br>
 ```2. 정확성 : 실시간으로 업데이트 되는 데이터를 사용함으로써, 유저에게 신뢰성 높은 정보를 전달할 수 있다.```<br>
  ```3. 다양성 : API에 의한 검색 결과를 통해 사용자는 위치, 평가, 가격 등을 비교, 평가할 수 있다.```<br>
  ```4. 시간 및 에너지 절약 : 일일이 헬스장을 찾아다니며 정보를 얻지 않고, API를 통해 불필요한 이동을 줄이고 잠재적 실수의 위험을 줄일 수 있다.```<br>
  ```5. 개인화된 추천 : 키워드에 맞추어 운동 종류, 예산, 거리 등을 고려하여 유저의 요구에 맞는 최적의 헬스장을 찾는데 줄 수 있다.```<br>
  
- 단점<br>
  ```1. 부정확성 : API는 실시간으로 업데이트 되는 데이터를 사용하지만, 개인 사업자가 운영 정보를 업데이트 하지 않을 경우 부정확한 결과를 사용자에게 제공할 수 있다.```<br>
  ```2. 누락된 정보 : API를 통해 검색된 헬즈앙의 정보가 모두 포함되어있지 않을 수 있다. 헬스장의 세부 내용에 관련된 정보가 누락되어 있을 가능성이 있기 때문에 유저의 추가적인 조사가 필요할 수 있다.```<br>
  ```3. API 사용 제한 : API의 사용량 제한이 존재할 수 있다. 만약 사용량이 초과될 경우를 고려하여 추가적인 예산 편성이 필요하다.```<br>
  ```4. 의존성 : API에 장애가 발생하면 검색 서비스가 중단될 수 있다. 이에 대한 대비 계획을 수립하는 것이 필요하다.```<br>
 
### Algo-02. API를 통한 사용자 요구에 맞는 운동자세 추천

- 요약
  과기부에서 제공하는 **질의 응답 API**를 활용하여 유저가 검색한 **키워드에 맞는 운동 자세**들을 위키 백과 기반으로 자세들을 추천
  
- 상세
	API에서 제공하는 JSON데이터의 헤드에 존재하는 데이터를 분석해서, 해당 **키워드와 관련된 헤더 정보를 가진 JSON데이터를 전달**해준다.

- 적용 알고리즘
**KMP** : KMP알고리즘을 통해 사용자가 작성한 키워드와 DB에 존재하는 데이터들을 비교하여, 일치하는 키워드를 가진 운동 자세 데이터들을 검색한다.
```java
KMP_Algorithm(text, pattern):
    n = len(text)          # 텍스트의 길이
    m = len(pattern)       # 패턴의 길이
    
    # 패턴 문자열의 접두사와 접미사를 미리 계산하는 전처리 과정
    pi = [0] * m           
    j = 0
    for i in range(1, m):
        while j > 0 and pattern[i] != pattern[j]:
            j = pi[j-1]
        if pattern[i] == pattern[j]:
            j += 1
            pi[i] = j
    
    # 문자열 검색 과정
    i = 0                  # 텍스트의 현재 인덱스
    j = 0                  # 패턴의 현재 인덱스
    while i < n:
        if text[i] == pattern[j]:
            i += 1
            j += 1
            if j == m:
                # 패턴을 찾음
                return i - m
        else:
            if j == 0:
                # 패턴의 첫 글자가 아닌 경우
                i += 1
            else:
                # 패턴의 일부를 찾았으나, 일치하지 않는 경우
                j = pi[j-1]
    
    # 패턴을 찾지 못한 경우
    return -1
```
**Kruskal** : 유저 평가 자료를 기반으로 운동 부위별 랭크에 가중치를 두어서 정렬한 결과를 나타낸다.
```java
Kruskal(graph):
    # graph: 입력 그래프 (간선과 가중치의 리스트)

    # 부모 노드를 저장하는 딕셔너리 초기화
    parent = {}
    for node in graph['nodes']:
        parent[node] = node

    # 간선을 가중치에 따라 오름차순으로 정렬
    edges = sorted(graph['edges'], key=lambda x: x[2])

    # 최소 신장 트리를 저장하는 리스트
    mst = []

    for edge in edges:
        u, v, weight = edge

        # 간선의 두 노드가 서로 다른 집합에 속해 있는지 확인
        if find(parent, u) != find(parent, v):
            # 두 노드가 다른 집합에 속해 있다면 해당 간선을 선택하여 최소 신장 트리에 추가
            mst.append(edge)
            # 두 노드가 속한 집합을 합침 (Union)
            union(parent, u, v)

    return mst

# 두 노드가 속한 집합을 찾는 함수 (Find)
def find(parent, node):
    if parent[node] == node:
        return node
    else:
        return find(parent, parent[node])

# 두 노드가 속한 집합을 합치는 함수 (Union)
def union(parent, u, v):
    u_root = find(parent, u)
    v_root = find(parent, v)
    parent[v_root] = u_root


```

- 이점 <br>
  ```1. 개인화된 운동 권장 : 질문 분석 API를 통해 사용자의 운동 목적과 요구를 분석하여, 개인에게 적합한 운동 자세를 추천할 수 있다. 이를 통해 사용자는 효과적이고 효율적인 운동을 할 수 있다.```<br>
  ```2. 운동의 정확성 향상 : 운동 자세에 대한 상세 내용을 기반으로, 사용자는 올바른 운동 자세를 유지하며 운동할 수 있어, 운동의 효과를 극대화하고 부상의 위험을 감소시킬 수 있다.```<br>
  ```3. 시간 및 노력 절감 : 운동 초보자나 새로운 운동을 시도하는 사용자가 어려움을 느낄 수 있는 부분을 API의 추천을 통해 해결함으로써, 사용자의 시간 및 노력 절감에 도움을 줄 수 있다.```<br>
 ``` 4. 사용자 경험 개선 : API를 통해 사용자 개인에게 맞는 운동자세를 추천함으로써, 보다 편리하고 효과적인 운동을 즐길 수 있어, 운동에 대한 흥미와 참여도 향상에 기여한다.```<br>
  
- 단점<br>
```1. 개인정보 보호 : 사용자의 운동 목적, 요구, 신체 정보 등의 개인정보를 필요로한다. 이에 따라 개인정보 보호와 관련된 법적, 윤리적 문제 발생 가능성이 존재한다. 개인정보를 보호하기 위한 법규를 준수하도록 노력해야 한다.```<br>
```2. 운동 다영성 및 개별적 요구 고려 : 검색 결과가 한정적이거나, 개인의 운동 요구와 맞지 않을 경우 사용자의 운동 경험과 효과가 제한될 수 있다.```<br>
```3. 사용자의 자체 판단 및 안전 고려 : API를 통해 추천되는 운동 자세는 자동적인 추천이므로, 사용자의 개인적인 판단과 안전을 고려하여 전문적인 가이드라인을 추가로 제공해야 합니다.```<br>

### Algo-03. API를 통한 사용자 건강상태 분석
- 요약
메디에이지에서 제공하는 **건강 API**를 통해 사용자 **맞춤형 개인 건강 관리**

- 상세
8가지의 건강 API를 통해 실제 건강과 노화 상태를 정확하게 반영한 건강지표인 **생체나이를 분석하고 제공**한다.

- 적용 알고리즘
**DFS** : 사용자의 건강상태 데이터에 따라 발생할 수 있는 질병을 탐색한다. (ex. 나이별 검색 -> 생활 패턴 -> 식습관 -> 운동량 등 순차적 탐색을 통해 세부적인 내용 검색)
```java
# 방문 여부를 확인하기 위한 set 자료구조
visited = set()

def dfs(node):
    # 현재 노드 방문 처리
    print(node)
    visited.add(node)
    
    # 현재 노드와 연결된 인접 노드들을 재귀적으로 방문
    for adjacent_node in graph[node]:
        if adjacent_node not in visited:
            dfs(adjacent_node)

# 시작 노드에서 DFS 호출
start_node = 'A'
dfs(start_node)
```

- 이점<br>
```1. 편리하고 빠른 분석 : API를 통해 쉽게 접근 가능한 인터페이스를통해 생체 나이 분석 결과를 빠르게 얻을 수 있다.```<br>
```2. 객체화된 데이터 제공 : API를 통해 제공된 객체화된 데이터를 이용하여 사용자의 생체나이 정보를 쉽게 이해하고 활용할 수 있다. 데이터의 가시화나 다양양한 분석을 통해 개인 건강 상태 평가 및 관리에 도움이 된다.```<br>
```3. 사용자 맞춤형 개인건강관리 : 사후적 치료가 아닌 사전 예방을 위한 개인 맞춤형 건강관리 서비스 제공 가능. 생활습관 개선 및 맞춤형 콘텐츠 제고 가능```<br>
```4. 다양한 응용 분야 : 사용자의 분석 결과를 활용하여, 개발자는 관련된 보험 설계나 의료비 예측을 해주는 서비스를 개발할 수 있다.```<br>
```5. 효율적인 자원 활용 : 일괄적인 분석을 통해 효율적인 자원 활용을 통한 시간과 비용 절감 효과를 얻을 수 있다.```<br>

- 단점<br>
```1. 개인정보 보호 : 개인의 생체나이와 관련된 데이터를 전달하고 처리하는 과정에서 법적, 윤리적 문제를 야기할 수 있다. 데이터의 보안과 개인정보 보호를 철저히 고려한 상태에서의 API활용이 이루어져야 한다.```<br>
```2. 의료 전문가의 필요성 : 일반 사용자를 대상으로 설계된 것이기 때문에 전문적인 해석과 판단이 필요한 경우 전문가의 도움이 필요할 수 있다. 전문가와의 연결해주는 서비스의 별도 개발이 필요하다.```<br>
```3. 의존성 및 제한된 활용 범위 : 특정한 용도로만 사용되기 떄문에 API에서 제공되는 기능과 정보가 한정되어있다. 다양한 용도와 분석을 위해서는 다른 API와 서비스가 필요할 수 있다. 또한 API에 의존적이기 때문에 해당 API의 정책 변화에 따라 활용 제한의 위험성이 존재한다.```<br>

### Algo-04. 개인형 맞춤 식단 추천
- 요약
지도 API와 개인 건상상태 분석 결과를 토대로 부족한 영양소를 보충할 수 있는 식단과 주변 음식점을 추천해준다.

- 상세
추천된 식단과 음식 키워드에 따라, 지도 API를 활용하여 주변에서 해당 음식 키워드를 가진 식당목록과 상세 정보를 지도에 나타낸다.

- 적용 알고리즘
**Greedy** : 칼로리와 만족도를 기반으로 최소 칼로리로 최대 만족도를 이끌어 낼 수 있는 식단을 도출한다.
```java
def dp_greedy_algorithm(arr):
    n = len(arr)
    # DP 테이블 초기화
    dp = [0] * n
    dp[0] = arr[0]

    # 그리디 알고리즘 적용
    for i in range(1, n):
        # 그리디 선택: 이전까지의 합과 현재 원소 중 최댓값 선택
        dp[i] = max(dp[i-1] + arr[i], arr[i])

    # 최종 결과 반환
    return max(dp)
```

- 이점<br>
```1. 개인화된 추천 : 개인의 건강 상태 분석결과를 기반으로 식단이나 식당을 추천하므로, 개인의 식습관, 건강상태, 영양 요구 등을 고려한 맞춤형 식단이 가능하다. 사용자는 이를 통해 건강한 식단을 선택하고, 영양 균형을 맞출 수 있다.```<br>
```2. 효율적인 시간 및 노력 절감 : 지도 API를 활용하여 사용자가 식당을 찾거나 검색하는 시간과 노력을 절감할 수 있고, 개별적인 식단 계획을 수립하는 과정에 도움을 줄 수 있다.```<br>
```3. 건강 증진 및 영양 개선 : 사용자가 건강한 식단을 선택하고 영양 균형을 맞추는데 도움을 준다.```<br>
```4. 사용자 경험 개선 : 사용자가 다양한 식당을 경험하여 영양 개선을 도모하고 만족도를 향상 시킬 수 있다.```<br>

- 단점<br>
```1. 개인정보 보호 : 개인의 생체나이와 위치정보에 관련된 데이터를 전달하고 처리하는 과정에서 법적, 윤리적 문제를 야기할 수 있다. 데이터의 보안과 개인정보 보호를 철저히 고려한 상태에서의 API활용이 이루어져야 한다.```<br>
```2. 정확성과 신뢰성 문제 : 건강 상태 분석결과와 식단, 식당 추천은 다양한 요소를 고려해야하기 때문에, 정확성과 신뢰성의 문제가 발생할 수 있다. 건강상태 분석이 정확하지 않거나, 식단 및 식당 추천 알고리즘이 부정확할 경우 사용자가 부적절한 선택을 하게 된다.```<br>
```3. 다양성 및 개별성 문제 : 개별 사용자의 식습관, 선호도, 건강 상태 등을 고려하기 때문에 다양성과 개별성에 대한 고려가 필요하다. 일부 사용자에게는 만족스럽지 못한 추천을 제공할 수 있다.```<br>
```4. 외부 데이터 의존성 : 외부 데이터에 대한 의존성이 높기 떄문에 데이터의 정확성, 신뢰성, 업데이트에 따라 추천 결과가 달라질 수 있다. 외부 데이터의 신뢰성을 확인하고 정기적인 업데이트가 이루어져야 한다.```<br>

## ⭐ 진행도
### 04 / 14
### [+] 추가
- 프로젝트 명세서 작성 및 기본 기능 작성

### 04 / 18
### [+] 추가
- 알고리즘 구현 완료

### 04 /27
### [+] 추가
-프론트 엔드 및 백엔드 구현

### 05 / 13
### [+] 추가
- API 연결 완료

### 05 / 24
### [+] 추가
- AWS를 통한 서버 배포 및 백엔드 서버 연결 완료

### 05 / 26
### [-] 수정
- 유저 피드백 반영 기능 수정

### [+] 추가
- 배포 완료


